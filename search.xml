<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[现代C++内存管理]]></title>
    <url>%2F2019%2F07%2F24%2F2019-7-24-%E7%8E%B0%E4%BB%A3C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[现代C++内存管理——如何使用智能指针显示内存管理C++98/C++03版本中，通常情况都是使用语言自带的new/delete或者new[] /delete[]来申请堆内存。但是C/C++中指针和引用的灵活性、分支、异常等情况，使得内存申请、使用、释放每一个步骤都需要程序员话费大量精力。即使仔细使用了，内存问题在大型工程中始终无法杜绝。常见的C++堆内存管理有一下问题： 野指针：某些内存已经释放，但是指向它的指针缺仍然在使用，当被系统重新分配时，会导致无法预测的错误。 重复释放：试图释放已经被释放的内存或者释放已经被重新分配的内存。 内存泄漏：不在使用的内存没有被释放。当程序是守护进程或者服务时，会导致内存剧增，甚至被占满。 虽然显示内存管理在性能上有一定的优势，但是总是无法给程序以信心，保证没有内存问题。在多线程，并发广泛应用的现在，内存问题会更加严重。&nbsp;现在各种编程语言都提供了更好的基础设施，让程序员摆脱内存管理的细节。详细请看下表。 编程语言 内存管理/垃圾回收机制 C++ C++11以上，基于引用计数的垃圾回收器 java 基于跟踪处理的垃圾回收器 python 基于跟踪处理的垃圾回收器 C 不支持 C#/Ruby/go/Perl/javascript 基于跟踪处理的垃圾回收器 Rust 类似C++中unique_ptr、借用、转移等方式管理内存，本质还是计数 基于引用计数的垃圾回收器：引用计数是记录对象被引用（指针，引用）的次数。当对象被引用的次数为0时，对象将被视作‘垃圾’而回收。优点是基于计数的方式不会造成程序的停顿，不会对系统的缓存、交换空间造成冲击，被认为副作用较小。基于跟踪处理的垃圾回收器：跟踪对象的关系图，然后进行垃圾回收，有标记-清除、标记整理、标记-拷贝等方式。 现代C++内存管理程序员自己管理内存虽然非常灵活，但是引入的问题总是会出现。现在大部分语言都提供了更加有效的内存管理方式，C++也已经跟上潮流，随着C++0x版本的发布，内存管理可以使用智能指针来实现。随着标准的不断迭代，内存管理会越来越方便。C++0x中使用unique_ptr、shared_ptr、weak_ptr来自动、异常安全的管理对象的的生命周期。 unique_ptr：独占（unique）指针，是通过占有并且管理一个另一个对象，当unique_ptr被销毁时，指向的对象将被释放。 shared_ptr: 共享型（shared）指针，允许多个指针指向同一个对象，使用引用计数来记录被引用的次数，当引用计数为0时，指向的对象被删除。 weak_ptr: 非拥有性（“弱”，weak）指针，对shared_ptr管理的对象有临时性的拥有权，用来解决shared_ptr环形引用问题。 shared_ptr详解shared_ptr采用引用计数来管理裸指针指向的对象（同一块堆内存），多个shared_ptr共同占有一个对象，当引用计数大于零时可以用，等于零时，释放指针指向的对象。shared_ptr有如下优点： 管理可能发生异常的内存或线程间的内存，放置发生内存泄漏 最后剩下的占有对象的shared_ptr被销毁、通过赋值，reset函数赋值给另一个指针时，引用计数为零，对象被删除（默认以delete删除，如果传递了删除器，则选择对应的删除器） 注意循环引用，循环引用会导致堆内存无法正确释放。 原型：123#include &lt;memory&gt;template&lt; class T &gt; class shared_ptr; 惯用法123456789101112131415161718class Person&#123;public: ~Person()&#123; cout &lt;&lt; "delete Person" &lt;&lt; endl; &#125; void print()&#123; cout &lt;&lt; "I'm a Person" &lt;&lt; endl; &#125;&#125;auto sp = std::make_shared&lt;int&gt;(5)shared_ptr&lt;Person&gt; sp2(new person () );sp2-&gt;print();//没有default_delete&lt;Person [] &gt;()程序异常退出shared_ptr&lt;Person&gt; sp3(new Person[2], default_delete&lt;Person [] &gt;());sp2.get()[0].print();sp2.get()[1].print();shared_ptr&lt;Person&gt; sp3(new Person[2],[](Person * p)&#123;delete [] p;&#125;); 注意事项 不要使用原始指针初始化多个shared_ptr,会造成多次销毁 123int *p5 = new int;std::shared_ptr&lt;int&gt; p6(p5);std::shared_ptr&lt;int&gt; p7(p5);// logic error this指针 使用场景：当类被shared_ptr管理，并且类的成员函数需要把当前对象最为参数传递给其他函数，此时需要传递一个指向自身的shared_ptr 原因：返回this，或者shared_ptr都是不对的。 1234567891011121314151617181920212223242526272829303132333435class A&#123;public: shared_ptr&lt;A&gt; get()&#123; return shared_ptr&lt;A&gt;(this); &#125; ~A()&#123;cout &lt;&lt; "~A called" &lt;&lt;endl;&#125;&#125;;class B&#123;public: B* get()&#123; return this; &#125; ~B()&#123;cout &lt;&lt; "~B called" &lt;&lt;endl;&#125;&#125;;class C : public enable_shared_from_this&lt;C&gt;&#123;public: shared_ptr&lt;C&gt; get()&#123; return shared_from_this(); &#125; ~C()&#123;cout &lt;&lt; "~C called" &lt;&lt;endl;&#125;&#125;;int main(int argc, char *argv[])&#123;// shared_ptr&lt;A&gt; aPtr(new A);// shared_ptr&lt;A&gt; a = aPtr-&gt;get();//二次释放// shared_ptr&lt;B&gt; bPtr(new B);// B *b = bPtr-&gt;get();// delete b;//失去shared_ptr管理内存的意义，同时如果delete返回的指针，将导致内存问题 shared_ptr&lt;C&gt; cPtr(new C); shared_ptr&lt;C&gt; c = cPtr-&gt;get();&#125; 线程安全问题 shared_ptr提供了内置类型同级别的线程安全性： 同一个shared_ptr对象可以被多线程同时读取 不同的shared_ptr对象可以被多线程同时修改，包含两个shared_ptr指向同一个裸指针 多线程对同一个shared_ptr对象进行读写，是线程不安全的 环形引用 123456789101112131415161718192021222324252627282930class E;class D&#123;public: D()&#123;cout &lt;&lt; "D constructed" &lt;&lt;endl;&#125; ~D()&#123;cout &lt;&lt; "~D Deconstructed" &lt;&lt;endl;&#125; void set(shared_ptr&lt;E&gt; e)&#123; _e = e; &#125;private: shared_ptr&lt;E&gt; _e;//引用D--&gt;shared_ptr换成weak_ptr&#125;;class E&#123;public: E()&#123;cout &lt;&lt; "E constructed" &lt;&lt;endl;&#125; ~E()&#123;cout &lt;&lt; "~E Deconstructed" &lt;&lt;endl;&#125; void set(shared_ptr&lt;D&gt; d)&#123; _d = d; &#125;private: shared_ptr&lt;D&gt; _d;//引用D--&gt;shared_ptr换成weak_ptr&#125;;int main(int argc, char *argv[])&#123; shared_ptr&lt;D&gt; d(new D); shared_ptr&lt;E&gt; e(new E); d-&gt;set(e); e-&gt;set(d); //无法释放&#125; weak_ptr详解weak_ptr是一种不控制对象生命周期的智能指针，为打断shared_ptr所管理的对象组成的环形引用而引入。 unique_ptr详解unique_ptr通过指针占有并且管理一个对象，当unique_ptr在离开作用域时释放对象的智能指针。原型：12345678template&lt; class T, class Deleter = std::default_delete&lt;T&gt;&gt; class unique_ptr;template &lt; class T, class Deleter&gt; class unique_ptr&lt;T[], Deleter&gt;; default_delete必须是函数对象或者函数对象的引用，会在unique_ptr析构的时候调用。 惯用法123456789101112131415//特列可以从函数中返回unique_ptr&lt;int&gt; clone(int p)&#123; unique_ptr&lt;int&gt; pInt(new int(p)); return pInt; // 返回unique_ptr&#125;unique_ptr&lt;int&gt; pInt(new int(1)); //创建//unique_ptr&lt;int&gt; pInt2(pInt); //报错//unique_ptr&lt;int&gt; pInt3 = pInt;//报错，禁止拷贝和赋值unique_ptr&lt;int&gt; pInt4(move(pInt));unique_ptr&lt;int&gt; pInt5 = move(pInt4);//支持移动语意，转移指针所有权unique_ptr&lt;int&gt; ret = clone(2);int *intValue = ret.release();//释放管理的对象指针，并释放所有权auto makePtr = std::make_unique&lt;int&gt;();//创建一个新对象的独占指针 makePtr.reset();//替换被管理的对象，此处参数为空，相当于将makePtr指针设置为空 使用场景 使用RAII，正常退出或者异常退出都能保证独占的对象被删除，是异常安全的。 123456void fun()&#123; unique_ptr&lt;int&gt; p(new int(1)); .... //发生异常&#125;退出作用域，unique_ptr删除，调用Deleter删除指针。 传递unique_ptr到函数，后者从函数返回 12345std::unique_ptr&lt;D&gt; pass_through(std::unique_ptr&lt;D&gt; p)&#123; p-&gt;bar(); return p;&#125; 在容器中使用unique_ptr 123vector&lt;unique_ptr&lt;int&gt;&gt; vec;unique_ptr&lt;int&gt; p(new int(1));vec.push_back(move(p)); 管理动态数组 12unique_ptr&lt;int[]&gt; p(new int[5] &#123;1, 2, 3, 4, 5&#125;);//创建p[0] = 0;//使用]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
