<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019-7-24-现代C++内存管理]]></title>
    <url>%2F2019%2F07%2F24%2F2019-7-24-%E7%8E%B0%E4%BB%A3C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[现代C++内存管理显示内存管理C++98/C++03版本中，通常情况都是使用语言自带的new/delete或者new[] /delete[]来申请堆内存。C/C++中指针的灵活性、分支、异常等情况。内存申请、使用、释放每一个步骤都需要程序员分析注意思考，使得内存问题在大型工程中始终无法杜绝。常见的C++堆内存管理有一下问题： 野指针：某些内存已经释放，但是指向它的指针缺仍然在使用，当被系统重新分配时，会导致无法预测的错误。 重复释放：试图释放已经被释放的内存或者释放已经被重新分配的内存。 内存泄漏：不在使用的内存没有被释放。当程序是守护进程或者服务时，会导致内存剧增，甚至被占满。 虽然显示内存管理在性能上有一定的优势，但是总是无法给程序以信心，保证没有内存问题。在多线程，并发广泛应用的现在，内存问题会更加严重。现在各种编程语言都提供了更好的基础设施，让程序员摆脱内存管理的细节。详细请看下表。 编程语言 内存管理/垃圾回收机制 C++ C++11以上，基于引用计数的垃圾回收器 java 基于跟踪处理的垃圾回收器 python 基于跟踪处理的垃圾回收器 C 不支持 C#/Ruby/go/Perl/javascript 基于跟踪处理的垃圾回收器 Rust 类似C++中unique_ptr、借用、转移等方式管理内存，本质还是计数 基于引用计数的垃圾回收器：引用计数是记录对象被引用（指针，引用）的次数。当对象被引用的次数为0时，对象将被视作‘垃圾’而回收。基于计数的方式不会造成程序的停顿，不会对系统的缓存、交换空间造成冲击，被认为副作用较小。基于跟踪处理的垃圾回收器：跟踪对象的关系图，然后进行垃圾回收，有标记-清除、标记整理、标记-拷贝等方式。 现代C++内存管理程序员自己管理内存虽然非常灵活，但是引入的问题也会更多。现在大部分语言都提供了更加有效的内存管理方式，C++也要跟上潮流，减轻程序员的负担。随着C++0x版本的发布，内存管理可以使用智能指针来实现。随着标准的不断迭代，内存管理会越来越方便。C++中使用unique_ptr、shared_ptr、weak_ptr来自动、异常安全的管理对象的的生命周期。 unique_ptr：独占（unique）指针，是通过占有并且管理一个另一个对象，当unique_ptr被销毁时，指向的对象将被释放。 shared_ptr: 共享型（shared）指针，允许多个指针指向同一个对象，使用引用计数来记录被引用的次数，当引用计数为0时，指向的对象被删除。 weak_ptr: 非拥有性（“弱”，weak）指针，对shared_ptr管理的对象有临时性的拥有权，用来解决shared_ptr环形引用问题。 shared_ptr详解weak_ptr详解unique_ptr详解]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
