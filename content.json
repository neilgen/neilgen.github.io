{"meta":{"title":"Ken & Emily的家","subtitle":null,"description":null,"author":"何应康","url":"http://kangling.club","root":"/"},"pages":[{"title":"about","date":"2019-04-21T06:22:13.000Z","updated":"2019-04-21T06:22:13.628Z","comments":true,"path":"about/index.html","permalink":"http://kangling.club/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-21T06:20:41.000Z","updated":"2019-04-21T09:22:15.355Z","comments":true,"path":"categories/index.html","permalink":"http://kangling.club/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-21T06:21:37.000Z","updated":"2019-04-21T09:22:41.229Z","comments":true,"path":"tags/index.html","permalink":"http://kangling.club/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2019-7-24-现代C++内存管理","slug":"2019-7-24-现代C++内存管理","date":"2019-07-24T14:45:46.000Z","updated":"2019-07-29T14:29:12.001Z","comments":true,"path":"2019/07/24/2019-7-24-现代C++内存管理/","link":"","permalink":"http://kangling.club/2019/07/24/2019-7-24-现代C++内存管理/","excerpt":"","text":"现代C++内存管理显示内存管理C++98/C++03版本中，通常情况都是使用语言自带的new/delete或者new[] /delete[]来申请堆内存。C/C++中指针的灵活性、分支、异常等情况。内存申请、使用、释放每一个步骤都需要程序员分析注意思考，使得内存问题在大型工程中始终无法杜绝。常见的C++堆内存管理有一下问题： 野指针：某些内存已经释放，但是指向它的指针缺仍然在使用，当被系统重新分配时，会导致无法预测的错误。 重复释放：试图释放已经被释放的内存或者释放已经被重新分配的内存。 内存泄漏：不在使用的内存没有被释放。当程序是守护进程或者服务时，会导致内存剧增，甚至被占满。 虽然显示内存管理在性能上有一定的优势，但是总是无法给程序以信心，保证没有内存问题。在多线程，并发广泛应用的现在，内存问题会更加严重。现在各种编程语言都提供了更好的基础设施，让程序员摆脱内存管理的细节。详细请看下表。 编程语言 内存管理/垃圾回收机制 C++ C++11以上，基于引用计数的垃圾回收器 java 基于跟踪处理的垃圾回收器 python 基于跟踪处理的垃圾回收器 C 不支持 C#/Ruby/go/Perl/javascript 基于跟踪处理的垃圾回收器 Rust 类似C++中unique_ptr、借用、转移等方式管理内存，本质还是计数 基于引用计数的垃圾回收器：引用计数是记录对象被引用（指针，引用）的次数。当对象被引用的次数为0时，对象将被视作‘垃圾’而回收。基于计数的方式不会造成程序的停顿，不会对系统的缓存、交换空间造成冲击，被认为副作用较小。基于跟踪处理的垃圾回收器：跟踪对象的关系图，然后进行垃圾回收，有标记-清除、标记整理、标记-拷贝等方式。 现代C++内存管理程序员自己管理内存虽然非常灵活，但是引入的问题也会更多。现在大部分语言都提供了更加有效的内存管理方式，C++也要跟上潮流，减轻程序员的负担。随着C++0x版本的发布，内存管理可以使用智能指针来实现。随着标准的不断迭代，内存管理会越来越方便。C++中使用unique_ptr、shared_ptr、weak_ptr来自动、异常安全的管理对象的的生命周期。 unique_ptr：独占（unique）指针，是通过占有并且管理一个另一个对象，当unique_ptr被销毁时，指向的对象将被释放。 shared_ptr: 共享型（shared）指针，允许多个指针指向同一个对象，使用引用计数来记录被引用的次数，当引用计数为0时，指向的对象被删除。 weak_ptr: 非拥有性（“弱”，weak）指针，对shared_ptr管理的对象有临时性的拥有权，用来解决shared_ptr环形引用问题。 shared_ptr详解weak_ptr详解unique_ptr详解","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://kangling.club/tags/C/"}]}]}